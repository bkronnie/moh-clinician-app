package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Weeklyreport represents a row from 'public.weeklyreport'.
type Weeklyreport struct {
	ID         int            `json:"id"`         // id
	Hospital   sql.NullInt64  `json:"hospital"`   // hospital
	Department sql.NullInt64  `json:"department"` // department
	Employee   sql.NullInt64  `json:"employee"`   // employee
	Title      sql.NullString `json:"title"`      // title
	Start      sql.NullTime   `json:"start"`      // start
	Stop       sql.NullTime   `json:"stop"`       // stop
	Qn01       sql.NullInt64  `json:"qn_01"`      // qn_01
	Qn02       sql.NullInt64  `json:"qn_02"`      // qn_02
	Qn03       sql.NullInt64  `json:"qn_03"`      // qn_03
	Qn04       sql.NullInt64  `json:"qn_04"`      // qn_04
	Qn05       sql.NullInt64  `json:"qn_05"`      // qn_05
	Qn06       sql.NullInt64  `json:"qn_06"`      // qn_06
	Qn07       sql.NullInt64  `json:"qn_07"`      // qn_07
	Qn08       sql.NullInt64  `json:"qn_08"`      // qn_08
	Qn09       sql.NullInt64  `json:"qn_09"`      // qn_09
	Qn10       sql.NullInt64  `json:"qn_10"`      // qn_10
	CreatedOn  sql.NullTime   `json:"created_on"` // created_on
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Weeklyreport] exists in the database.
func (w *Weeklyreport) Exists() bool {
	return w._exists
}

// Deleted returns true when the [Weeklyreport] has been marked for deletion
// from the database.
func (w *Weeklyreport) Deleted() bool {
	return w._deleted
}

// Insert inserts the [Weeklyreport] to the database.
func (w *Weeklyreport) Insert(ctx context.Context, db DB) error {
	switch {
	case w._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case w._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.weeklyreport (` +
		`hospital, department, employee, title, start, stop, qn_01, qn_02, qn_03, qn_04, qn_05, qn_06, qn_07, qn_08, qn_09, qn_10, created_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17` +
		`) RETURNING id`
	// run
	logf(sqlstr, w.Hospital, w.Department, w.Employee, w.Title, w.Start, w.Stop, w.Qn01, w.Qn02, w.Qn03, w.Qn04, w.Qn05, w.Qn06, w.Qn07, w.Qn08, w.Qn09, w.Qn10, w.CreatedOn)
	if err := db.QueryRowContext(ctx, sqlstr, w.Hospital, w.Department, w.Employee, w.Title, w.Start, w.Stop, w.Qn01, w.Qn02, w.Qn03, w.Qn04, w.Qn05, w.Qn06, w.Qn07, w.Qn08, w.Qn09, w.Qn10, w.CreatedOn).Scan(&w.ID); err != nil {
		return logerror(err)
	}
	// set exists
	w._exists = true
	return nil
}

// Update updates a [Weeklyreport] in the database.
func (w *Weeklyreport) Update(ctx context.Context, db DB) error {
	switch {
	case !w._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case w._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.weeklyreport SET ` +
		`hospital = $1, department = $2, employee = $3, title = $4, start = $5, stop = $6, qn_01 = $7, qn_02 = $8, qn_03 = $9, qn_04 = $10, qn_05 = $11, qn_06 = $12, qn_07 = $13, qn_08 = $14, qn_09 = $15, qn_10 = $16, created_on = $17 ` +
		`WHERE id = $18`
	// run
	logf(sqlstr, w.Hospital, w.Department, w.Employee, w.Title, w.Start, w.Stop, w.Qn01, w.Qn02, w.Qn03, w.Qn04, w.Qn05, w.Qn06, w.Qn07, w.Qn08, w.Qn09, w.Qn10, w.CreatedOn, w.ID)
	if _, err := db.ExecContext(ctx, sqlstr, w.Hospital, w.Department, w.Employee, w.Title, w.Start, w.Stop, w.Qn01, w.Qn02, w.Qn03, w.Qn04, w.Qn05, w.Qn06, w.Qn07, w.Qn08, w.Qn09, w.Qn10, w.CreatedOn, w.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Weeklyreport] to the database.
func (w *Weeklyreport) Save(ctx context.Context, db DB) error {
	if w.Exists() {
		return w.Update(ctx, db)
	}
	return w.Insert(ctx, db)
}

// Upsert performs an upsert for [Weeklyreport].
func (w *Weeklyreport) Upsert(ctx context.Context, db DB) error {
	switch {
	case w._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.weeklyreport (` +
		`id, hospital, department, employee, title, start, stop, qn_01, qn_02, qn_03, qn_04, qn_05, qn_06, qn_07, qn_08, qn_09, qn_10, created_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`hospital = EXCLUDED.hospital, department = EXCLUDED.department, employee = EXCLUDED.employee, title = EXCLUDED.title, start = EXCLUDED.start, stop = EXCLUDED.stop, qn_01 = EXCLUDED.qn_01, qn_02 = EXCLUDED.qn_02, qn_03 = EXCLUDED.qn_03, qn_04 = EXCLUDED.qn_04, qn_05 = EXCLUDED.qn_05, qn_06 = EXCLUDED.qn_06, qn_07 = EXCLUDED.qn_07, qn_08 = EXCLUDED.qn_08, qn_09 = EXCLUDED.qn_09, qn_10 = EXCLUDED.qn_10, created_on = EXCLUDED.created_on `
	// run
	logf(sqlstr, w.ID, w.Hospital, w.Department, w.Employee, w.Title, w.Start, w.Stop, w.Qn01, w.Qn02, w.Qn03, w.Qn04, w.Qn05, w.Qn06, w.Qn07, w.Qn08, w.Qn09, w.Qn10, w.CreatedOn)
	if _, err := db.ExecContext(ctx, sqlstr, w.ID, w.Hospital, w.Department, w.Employee, w.Title, w.Start, w.Stop, w.Qn01, w.Qn02, w.Qn03, w.Qn04, w.Qn05, w.Qn06, w.Qn07, w.Qn08, w.Qn09, w.Qn10, w.CreatedOn); err != nil {
		return logerror(err)
	}
	// set exists
	w._exists = true
	return nil
}

// Delete deletes the [Weeklyreport] from the database.
func (w *Weeklyreport) Delete(ctx context.Context, db DB) error {
	switch {
	case !w._exists: // doesn't exist
		return nil
	case w._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.weeklyreport ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, w.ID)
	if _, err := db.ExecContext(ctx, sqlstr, w.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	w._deleted = true
	return nil
}

// WeeklyreportByID retrieves a row from 'public.weeklyreport' as a [Weeklyreport].
//
// Generated from index 'weeklyreport_pkey'.
func WeeklyreportByID(ctx context.Context, db DB, id int) (*Weeklyreport, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, hospital, department, employee, title, start, stop, qn_01, qn_02, qn_03, qn_04, qn_05, qn_06, qn_07, qn_08, qn_09, qn_10, created_on ` +
		`FROM public.weeklyreport ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	w := Weeklyreport{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&w.ID, &w.Hospital, &w.Department, &w.Employee, &w.Title, &w.Start, &w.Stop, &w.Qn01, &w.Qn02, &w.Qn03, &w.Qn04, &w.Qn05, &w.Qn06, &w.Qn07, &w.Qn08, &w.Qn09, &w.Qn10, &w.CreatedOn); err != nil {
		return nil, logerror(err)
	}
	return &w, nil
}
